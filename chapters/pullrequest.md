# プルリクエストしてみたい！

「プルリクエスト」は元々はGitHubの用語で、GitHub登場以前は一般的には「パッチを送る」とか「変更を取り込んでもらう」といった言い方をされていました。また、GitLabでは同じような機能が「マージリクエスト」という名前になっています。

色々な言い方はありますが、本書ではGitHubや同様の形態のサービスで変更を取り込んでもらうことも、伝統的なパッチ形式で変更を提案することも、便宜的にすべて「プルリクエスト」と呼称することにします。

Gitの使い方やGitHubを使ったプルリクエストの方法自体の解説は、初心者にも分かりやすい解説に定評のある湊川あい氏によるWeb連載の「[マンガでわかるGit](https://next.rikunabi.com/journal/tag/webdesign-manga/)」や、その増補改訂版の書籍「わかばちゃんと学ぶ Git使い方入門」（シーアンドアール研究所より2017年刊行）などで学ぶことができます。

しかし、そうして「プルリクエストする方法」は分かっても、実際のOSSでプルリクエストするのにはまだ抵抗がある、という人もいるのではないでしょうか。この節ではそんな方のために、見ず知らずの相手が運営しているOSSプロジェクトにプルリクエストするときの取り組み方を説明してみます。

なお、本書ではGitやGitHubなどの使い方自体は、詳しくは解説しません。GitHub自体まだ使ったことがない方は、今はこの章の内容は流し読み程度に留めて、前述の参考書籍などに目を通してからまた読み返して頂ければ幸いです。






## マージされやすいプルリクエストにしよう

### 変更の意図をきちんと説明しよう

OSS Gateワークショップは、まだOSSにフィードバックをした事がない人に「不具合や要望を報告する過程を体験する」という事を目標にしています。しかしOSS開発に参加してみたいという人の中には、「実際にコードを書く事を通じて参加したい」という思いが強い人もいるでしょう。また、「英語の読み書きは苦手だけれどもコードなら書ける」ということで、英語で長々と説明するよりも端的にコードの提供だけで済ませたい人もいると思います。筆者もそのように考えていましたし、今でもいきなりプルリクエストを送るという場面は度々あります。

ただ、何の説明もないプルリクエストだけが単発で送られてきても、開発者は戸惑います。仮に1行だけの変更であっても、その変更が何を意図していてどういう影響があるのか、ぱっと見で分からないからです。

「開発者なんだからプロジェクトの隅々まで100%完璧に把握してるはずだろう、だったら説明なんかしなくてもコードを見れば分かるはずだ」と思いますか？　残念ながら、それは過剰な期待というものです。*開発者といえど、ある程度以上の複雑さを持ったソフトウェアでは、どの変更がどこにどういう影響を与えるのかを一目で判断するのは難しいです*。変更が予想外の場所で不具合を引き起こす「後退バグ」が起こったり、後退バグの早期検出を図る「回帰テスト」があったりするのは、そのためです。

開発者がプルリクエストの内容をスムーズに理解し、レビューやマージするかどうかの判断を迅速に行えるようにするためにも、経緯や過去の議論を参照しやすいようにしておくことが望ましいです。なので、プルリクエストには*特定のイシューの番号（もしくはURL）を添えて「これを修正するための変更です」という説明を加える*（英語では「This fixes the issue #12345.」）のが一般的です。

イシューと紐付けないでプルリクエストをいきなり出すのであれば、そのプルリクエストの説明として、「修正したい現象の再現手順」「実際に得られた結果」「期待される結果」を説明し、その変更が「期待される結果」を得られるようにするためのものだ、という情報を添えるのが望ましいです。つまり、イシューと同等の情報量が必要ということで、結局やることは変わりません。

### 議論の余地が無い変更なら、プルリクエストから始めてもいい場合はある

動作そのものに影響がなく、是非の議論の余地が無い変更の場合、イシューを経ずにプルリクエストから始めても問題無いことがあります。例えば以下のようなケースです。

* ローカルな変数名やプライベートな関数名の綴り間違いの修正
* 言語リソースの誤訳の修正
* 言語リソースの未翻訳部分に対する訳文の追加
* Webサイトやドキュメントの誤記の修正
* Webサイトやドキュメントのリンク切れの修正

こういうものは「再現手順」「実際に得られた結果」「期待される結果」の枠に当てはめにくいので、イシューを立てようと思うと逆に難しいです。実際のプロダクトやドキュメントに残る形でフィードバックをしたいという思いが強い場合には、こういったものから手を着けてみるのもよいかもしれません。

GitHub上では、ログイン済みの状態でファイルの個別のページを表示すると、オンラインで編集を開始できます。他人のリポジトリだった場合、変更を保存するタイミングで自動的に自分のアカウント配下にフォークが作られて、プルリクエストの作成画面になります。GitLabやBitBucketなどのサービスでも、操作の順番は多少異なりますが、同様のことができます。

（スクリーンショット：編集→プルリクエストの作成画面 の様子）

ただ、変更時に意図せず混入してしまった文法エラーによって、その変更をマージすると初期化に失敗して起動できなくなってしまったり、ドキュメントのレイアウトが崩れてしまったり、というようなケースはあります。筆者が公開しているFirefox用アドオンにおいても、日本語と英語以外の翻訳リソースを提供してもらえることがありますが、文法エラーが残ったままの状態でマージしてしまって、自分の手元の環境で突然動かなくなって焦った、ということが度々ありました[^auto-lint]。Webサイト上からのファイル編集でプルリクエストした場合などには事後的にでもよいので、*どんな変更であっても、必ず一度は自分の手元で動かして（表示して）みて、問題が無いかどうかを確認するようにしましょう*。

[^auto-lint]: そのため現在は、コミットやマージの際に自動的に文法チェックを行うような設定をしていて、マージ前にそれらのミスに気付けるようにしています。

また、*変数名・関数名・API名といった、動作に影響を与える部分の誤記の修正は、特に慎重に行う必要があります*。ローカル変数やプライベートなメソッド・関数は、他から参照されないため、変更しても動作が壊れることはあまりありません。しかし、グローバルな変数や公開のメソッド、モジュール名自体の誤記は、下手に変更すると動作を壊してしまうことがあります。また、一見するとプライベートな変数や関数であっても、コード片単位でのインクルードや、メタプログラミングによって実行時に外部から参照されるなどのことによって、変更が思わぬ所に影響を及ぼしてしまうリスクがあります。実行可能なコードに関わる変更は、原則として、GitHubなどのサイト上から編集して直接プルリクエストするやり方を取らずに、手元で動作に問題が無いことを確認してからプルリクエストを出すようにすることを強くお勧めします。

なお、プロジェクトメンバー間での対面での相談やチャットなど別の場所で既に議論が尽くされていて、後はコードを変更するだけであるという場合に、傍目からは「急にプルリクエストが行われて、何故かすぐにマージされた」という見え方になる場合もあります。これは経緯を知らない人には区別が付かないので、注意が必要です。「あっちはすぐにマージしてるのに、なんでこっちは放ったらかしにされるんだ！」と思うようなケースに遭遇した場合でも、「ならば自分も」と短絡的には考えないようにしましょう。

### 「馴染むコード」を書こう

きちんとイシューに紐付けたプルリクエストなのに、何カ所も指摘が付いて、なかなかマージしてもらえない……という場合、そもそもその変更内容が*元のコードに馴染んでいない*可能性があります。

理想的なプルリクエストは、「元々の開発者が書いていたら、きっとこう書いていただろう、と思える」「後からコード全体を通して見ても、どこが元の開発者の手による箇所で、どこがプルリクエストで変更された箇所か、見分けが付かない」というものです。技術力があまりに違いすぎると、加えた変更が「馴染まないコード」として悪目立ちしてしまいがちです。

「ということは、元々の開発者と同じレベルの技術力が無いとプルリクエストしちゃ駄目ってことなのか！」と思ってしまうかもしれませんが、それはちょっと早計です。

確かに、まったく新しいモジュールを追加するような変更になると、そのレベルで「馴染むコード」を書くには、元の開発者と同等の技術力が必要になってくるでしょう。ですが、「既存のモジュールの、特定の関数の中だけの変更」というように限定的な場面であれば、スーパーエンジニアでなくても「馴染むコード」は書けます。

というのも、多くのOSSでは、全体に渡って超絶技巧が凝らされているわけではありません。心臓部になるような部分は別としても、*部分部分だけを取り出して見れば、特に末端ほど、どこにでもあるようなごく普通のコードになっています*[^importance-of-readability]。考えてみれば当たり前の話で、「ボタンがクリックされた時の動作の定義の仕方」だったり「ファイルの読み込み方」だったり、そういったものは誰がどう書いても同じにしかなりようがないですよね。

[^importance-of-readability]: そもそも、OSSで「難解で分かりにくいコード」を書くのは、開発者にとっても自殺行為です。性能的な問題とならない限りは、なるべく可読性の高いコードにしてメンテナンス性を高く保っておかないと、開発者自身が後々困ることになります。

皆さんがOSSのソースコードを前にしてたじろぐのは、どこに何があるのか分からない状態の物がたくさん積み重なっているせいで、一つの「何か巨大なスゴイ物」に見えているからでしょう。近付いてよく見てみれば、「どこかで見たことがあるような書き方だ」と感じる箇所がそこかしこに見つかるはずです。

慣れないうちは、コードの変更に取り組むときは、部分部分で見た時に「これなら自分でも理解できる」という範囲で取り組むようにしましょう。少し背伸びして「ちょっと難しいかも……」という課題に取り組むのは、簡単な課題の解決で自信を付けてからにすることを、筆者としてはおすすめします。

### コラム：「Good First Issue」から始めるフィードバック

本書では基本的に「自分が遭遇したつまずきを報告する」という流れでのフィードバックを推奨しています。しかし、まだ何もつまずいていないものの、自分が普段からお世話になっている有名なOSSの開発に参加してみたい、問題解決に取り組んだりプルリクエストを出したりしてみたい、という人もいるかもしれません。あるいは、つまずいた問題が大きすぎて、自分には手に負えない、という場合もあるかもしれません。

そういう人は、そのプロジェクトのイシュートラッカーで「Good First Issue」や「Good First Bug」などとタグ付けされたイシューを探してみるとよいかもしれません。規模の大きなプロジェクトで、プロジェクトに協力してくれる人を随時募っている場合には、新規のプロジェクト参加者が挑戦するのにちょうどいい難易度の課題に、そのようなタグが付けられている場合があります。

取り組めそうな課題を見つけたら、「これに挑戦します」と宣言するコメントを追加して、進捗状況を随時共有しながら取り組んでみるとよいでしょう。分からないことがあったら、質問をするとプロジェクトに参加中の先達からアドバイスをもらえるかもしれません。




変更を分ける。
複数の変更を一度に投げない。






OSS初心者がつまづきながらOSSマナーを学んでいく話 - Speaker Deck
https://speakerdeck.com/fuqda/osschu-xin-zhe-gatumadukinagaraossmanawoxue-ndeikuhua-4edf8e12-a019-4fa6-bc93-5be40a788e86

OSSで結果を出す方法 - Speaker Deck
https://speakerdeck.com/knu/ossdejie-guo-wochu-sufang-fa?slide=3

このあたりで語られているような内容。








## テストを直してみよう

### テストを実行してみよう

プルリクエストの中でもあまり議論の余地なく受け入れてもらいやすい物に、「自動テストの修正[^what-is-automated-test]」があります。

[^what-is-automated-test]: 自動テストとは、「テストの手順、実測値、期待値」の3つを定義しておき、手順の実行結果の実測値が期待値と異なっていればテスト失敗の旨を教えてくれる、というプログラムのことを言います。最も単純な例では、ある関数を引数を変えながら何度か呼び、関数の戻り値が想定通りかどうかを比較して、一致していれば成功、不一致なら失敗とする、といった要領です。

プロジェクトによっては、説明文の中にテストの実行手順が書かれている場合があります。その場合、*ソースコードをダウンロードしたら、まずはテストを実際に動かしてみましょう*。

実行手順が書かれていないけれどもテストらしきファイル（`test`や`tests`と名付けられたフォルダー）があるという場合、ソフトウェアの種類によっては、一般的なテストの実行手順を適用できる場合があります。例えば、Node.jsのnpmのモジュールなら`npm install && npm run test`、RubyのGemなら`bundle install && bundle exec rake test`といったコマンド列を端末上のシェルで実行する方法が一般的です。

テストの実行手順がどうしても分からない場合は、「実行手順が説明に書かれていないので、テストを実行できない」ということ自体をイシューとして報告してみましょう。また、うまくテストを実行できたら、その手順を説明に追加するプルリクエストを出すようにしましょう。そうすることで、次以降に同じ所でつまずく人が減ります。

### 失敗しているテストを直そう

自動テストは、基本的にはすべて成功する状態になっていることが期待されます。しかし、プロジェクトによっては、自動テストが失敗する状態になっていることがあります。開発者がそのことに気付いていない場合もありますし、気付いていてあえて放置している場合もあります。いずれにしても、*自動テストの失敗は、開発者の手が回っていないということの表れ*ですから、今まさにコントリビュートが望まれている状態だと言えるでしょう。テストがすべて成功する状態に修正するプルリクエストは、開発者も大抵は喜んでマージしてくれるはずです。

自動テストの壊れ方には、「実装の方が壊れている場合」と「テストの方が壊れている場合」の2種類があります。実装の方が壊れているとは、つまり、後退バグが発生しているということです。テストの方が壊れているとは、実装が変化したり[^test-fail-from-updated-implementation]実行環境の事情が変わったりした[^test-fail-from-updated-environment]にもかかわらず、自動テストの方にそれが反映されていない、ということです。放置されていることが多いのは後者のパターンでしょう。というのも、後者の状態でも通常の使用そのものには支障はないからです。

[^test-fail-from-updated-implementation]: 例えば、「関数に機能が追加されて引数の数が2つから3つに増えたにもかかわらず、テストでは引数を2つしか渡していない」「関数の戻り値の種類が整数から小数に変わったのに、テストでは小数が返ってくることを想定していない」などのような場合。
[^test-fail-from-updated-environment]: 例えば、「実験的に導入されていた演算子をテストで使っていたが、実行環境が更新されてその演算子が廃止された」「テストで使っていた組み込みのクラスが、その言語の新しいバージョンでは廃止された」などのような場合。

自動テストはそのOSSの「期待される動作」「詳細な使い方」を説明するものでもあります。テストを熟読しながら、なぜテストが失敗しているのか原因を調べて、すべて成功する状態に修正する、という作業をすると、確実にそのOSSへの理解が深まります。OSSでテストの失敗に遭遇したら、是非挑戦してみて下さい。


