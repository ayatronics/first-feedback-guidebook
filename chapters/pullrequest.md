# プルリクエストをマージしてもらえない！

「プルリクエスト」は元々はGitHubの用語で、GitHub登場以前は一般的には「パッチを送る」とか「変更を取り込んでもらう」といった言い方をされていました。また、GitLabでは同じような機能が「マージリクエスト」という名前になっています。色々な言い方はありますが、本書ではGitHubや同様の形態のサービスで変更を取り込んでもらうこと全般をひっくるめて「プルリクエスト」と呼称することにします。

プルリクエストは、イシューとして報告された問題を実際に解決するための変更の提案です。イシューが却下されることがあるのと同様に、プルリクエストも却下される場合はあります。この節では、プルリクエストするときの様々な注意事項をご紹介していきます。


## イシュー無しでプルリクエストするのは、基本的には控えよう




## プルリクエストから始めると、泥沼にはまりやすい








### 議論の余地が無い変更なら、プルリクエストから始めてもいいけど……

*誰の目にも明らかなミスの訂正や、翻訳関係の変更など、是非の議論の余地が無い変更*の場合、イシューを経ずにプルリクエストから始めても問題無いと筆者は考えています。ソースコード上のミスタイプ（綴りの間違い）の修正や、言語リソースの翻訳ミスの修正、未翻訳部分の訳文の追加などがこれにあたります。

なお、プロジェクトメンバー間での対面での相談やチャットなど別の場所で既に議論が尽くされていて、後はコードを変更するだけであるという場合に、傍目からは「急にプルリクエストが行われて、何故かすぐにマージされた」という見え方になる場合もあります。これは経緯を知らない人には区別が付かないので、注意が必要です。

また、時には「誤記のように見えて実は意図的にそう書いてあった」「一般的な文脈では誤訳に見えるが、他のアプリケーションに合わせるとその訳の方が適切である」のような場合もあります。








OSS初心者がつまづきながらOSSマナーを学んでいく話 - Speaker Deck
https://speakerdeck.com/fuqda/osschu-xin-zhe-gatumadukinagaraossmanawoxue-ndeikuhua-4edf8e12-a019-4fa6-bc93-5be40a788e86

OSSで結果を出す方法 - Speaker Deck
https://speakerdeck.com/knu/ossdejie-guo-wochu-sufang-fa?slide=3

このあたりで語られているような内容。


実装する手が足りなくて却下されるときはプルリクエストを出すと話が進むこともある。
方針が合わないと、プルリクエスト出してもマージしてもらえない。


また、コードに対する変更でのフィードバックをしてもよいでしょう。GitHub上でホストされているプロジェクトであれば、



----

OSS Gateワークショップは、まだOSSにフィードバックをした事がない人に「不具合や要望を報告する過程を体験する」という事を目標にしています。しかしOSS開発に参加してみたいという人の中には、「実際にコードを書く事を通じて参加したい」という思いが強い人もいるでしょう。また、「英語の読み書きは苦手だけれどもコードなら書ける」ということで、英語で長々と説明するよりも端的にコード（プルリクエスト）だけで済ませたいという人もいると思います。筆者もそのように考えていましたし、今でもいきなりプルリクエストを送るという場面は度々あります。




## コラム：「Good First Issue」から始めるフィードバック

本書では基本的に「自分が遭遇したつまずきを報告する」という流れでのフィードバックを推奨しています。しかし、まだ何もつまずいていないものの、自分が普段からお世話になっている有名なOSSの開発に参加してみたい、問題解決に取り組んだりプルリクエストを出したりしてみたい、という人もいるかもしれません。あるいは、つまずいた問題が大きすぎて、自分には手に負えない、という場合もあるかもしれません。

そういう人は、そのプロジェクトのイシュートラッカーで「Good First Issue」や「Good First Bug」などとタグ付けされたイシューを探してみるとよいかもしれません。規模の大きなプロジェクトで、プロジェクトに協力してくれる人を随時募っている場合には、新規のプロジェクト参加者が挑戦するうのにちょうどいい難易度の課題にそのようなタグが付けられている場合があります。「これに挑戦します」と宣言するコメントをして、進捗状況を随時共有しながら課題の解決に取り組んでみるとよいでしょう。分からないことがあったら、質問をするとプロジェクトに参加中の先達からアドバイスをもらえるかもしれません。

[Node.jsへのコントリビュート解説、そしてOSSへ貢献するということ - 別にしんどくないブログ](https://shisama.hatenablog.com/entry/2019/12/04/204400#%E8%8B%B1%E8%AA%9E%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)



### コラム：自動テストと良い報告の類似性


開発現場でソフトウェア開発を手がけている人にとっては、「再現手順」「実際の結果」「期待される結果」の3要素に近い物にすでに馴染みがあるかもしれません。それは、自動テストです。

自動テストは、「テストの手順、実測値、期待値」の3つを定義しておき、手順の実行結果の実測値が期待値と異なっていればテスト失敗と見なすというものです。

報告の内容をそのままテストにした回帰テストが有効





## 悪いフィードバック：プロジェクトの背景を踏まえないハックの提案

筆者も、過去に強引な実装のパッチを代理で投稿してもらった事がありましたが、実装の筋が悪すぎたためか、それ以上話が進む事はありませんでした。

[61846 - Undockable My Sidebar - in a new window](https://bugzilla.mozilla.org/show_bug.cgi?id=61846)










## 何をしても駄目なときは

### フォークするしかない？　無闇にフォークしちゃ駄目？

問題を再定義して、プロジェクトのスコープに収まるようにして、筋の良い実装も用意して、それでも要望を受け入れてもらえない、ということはあります。最終的に要望を受け入れるかどうかは、そのプロジェクト内部の人が決定することです。外部から協力するだけの立場の人には、残念ですがその判断への介入はできません。

そういうときに、外部協力者の立場で取れる最後の手段が「フォーク」です。設定されているライセンスの条件に従う限り、誰もが自由にそのOSSを改造し、再配布することができます。その改造の成果を元の開発プロジェクトに還元しないまま独立したプロジェクトとして継続する、という選択肢です。

リソースの無駄な分散を防ぐためにも、ユーザーの混乱を避けるためにも、*フォークは可能な限り避けるのが望ましい*です。どうしてもフォークする場合は、それ以後の開発やメンテナンスに要するすべてのリソースを自前でまかない、最後までそのソフトウェアの面倒を見続ける覚悟が必要です。

そのため、大きなOSSプロジェクトほど、フォークは珍しいです。近年で観測された大きなフォークといえば、WebKitからGoogleがフォークして始めたBlinkのように、フォーク主体に膨大なリソースがある場合か、OpenOffice.orgからのLibreOfficeya
ownCloudからのNextcloudのように、フォーク元の主要開発者達が何らかの理由で元プロジェクトから離反して、フォーク先にそのまま合流した場合くらいでしょう。

Firefox 28からフォークしたPale Moonや、Firefox 56からフォークしたWaterfoxのように、個人や少人数のグループが大規模なプロジェクトをフォークしたケースは、健全な状態を保ち続けられていないことが多い、という印象が筆者にはあります[^forked-gecko]。「フォークしたはいいものの、実際やってみたら意外と大変で、しばらくしたら更新が滞ってしまいました」というのは、ユーザーに過剰な期待を持たせた挙げ句に振り回してしまう、最悪の結末です。

[^forked-gecko]: これらのフォーク版は、フォーク以後のFirefoxで行われた性能向上や安全性向上のための抜本的な変更、最新のWeb技術への対応などが反映されておらず、最新のFirefoxと比べるとだいぶ見劣りする状態になっています。

### いざというときの選択肢として

しかし、そうは言っても「絶対にフォークしてはならない」というわけでもありません。

上述のとおり、プロジェクトの運営主体を完全に引き継いで責任を持って継続できそうなのであれば、あるいは、フォーク版を自分しか使わなくて不利益はすべて折り込み済みなのであれば、フォークは選択肢の一つとして考慮する価値があります。実際に筆者にも、元プロジェクトには絶対に取り込んでもらえない独自の機能が、どうしても切実に業務上必要だという理由で、他の人の開発したOSSをフォークして以後、ニーズに応じて回収を続けながら10年近く維持し続けている[実例](https://github.com/clear-code/flex-confirm-mail/)があります。

「いざとなったらフォークして続けられる」という点は、OSSの強みです。もしフォークという手段が許されていなければ、やりたいビジネスを諦めたり、自分の使い方での致命的な不便を強いられたりしなくてはなりません。覚悟と努力次第で困難を乗り越えられる余地が常に残されているということに、筆者はこの上ない安心感を覚えます。

「そんなタフな選択ができるのは、あなた（筆者）がスーパーエンジニアだからだ」と思われるでしょうか？　いいえ、そんなことはありません。筆者のOSS開発者としてのキャリア自体、他の人が開発を放棄して動かなくなってしまったソフトウェアを、再び動くように見よう見まねで修正したところから始まっています[^fork-of-non-free-software]。当時の筆者はオブジェクト指向もロクに分かっていないようなド素人でした。その元ソフトウェアはごく単純な物でしたが、それでも当時の筆者にとっては、全貌を理解しきれない、手に余る代物としか思えませんでした。

[^fork-of-non-free-software]: 実を言うと、このときフォークの元にしたソフトウェア（Mozilla Application Suiteのコンテキストメニュー拡張機能）にはオープンソースライセンスが設定されていませんでした。自分の記憶が正しければ、元の作者の方が「習作のような物なので権利は主張しない」という旨のことをおっしゃっていたため、パブリックドメイン扱いとして、こちらでオープンソースなライセンスを設定したという経緯だったように思います。

しかし、動かなくなっていた原因箇所をどうにか直して動く状態に戻せたことで、筆者はそれを足がかりとして学習を進められました。当時の筆者にとっては、入門書に書かれていた内容（基本中の基本）と自分のやりたかった事（高度なGUIを持つソフトウェア）との間のギャップが大きすぎて途方に暮れていましたが、「すでに動く状態のソフトウェア」のソースコードを読むことによって、「そうか、こういう機能を作りたいときはこういう書き方をするんだ」という実践的な知識を得ていけたのでした。

また、ソフトウェアの公開の仕方、継続的なメンテナンスの仕方、要望の受け答えの仕方など、コーディングそのものとは異なる周辺領域の様々な経験についても、そうして「自分のプロジェクト」を持つようになって以降、必要に迫られて身に着ける形で、非常に多くのものを得られました。

本書は「OSSへのフィードバックの仕方」を解説していますが、実際の所、良いフィードバックとは「プロジェクトオーナーが受け取って嬉しいと思えるフィードバック」の一言に尽きます。どうだったら嬉しいのかということは、プロジェクトオーナーの側になってみるとよく分かる部分が多々あります。そういう経験を得る機会になるという意味で、皆さんもフォークをきっかけに「自分のプロジェクト」を持ってみてはいかがでしょうか？
