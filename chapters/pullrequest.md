# プルリクエストしてみたい！

「プルリクエスト」は元々はGitHubの用語で、GitHub登場以前は一般的には「パッチを送る」とか「変更を取り込んでもらう」といった言い方をされていました。また、GitLabでは同じような機能が「マージリクエスト」という名前になっています。

色々な言い方はありますが、本書ではGitHubや同様の形態のサービスで変更を取り込んでもらうことも、伝統的なパッチ形式で変更を提案することも、便宜的にすべて「プルリクエスト」と呼称することにします。この節では、プルリクエストするときの考え方や注意事項をご紹介します。

ただし、本書ではGitなどのバージョン管理ツールや、GitHubなどのサービス上でのプルリクエストの仕方そのものは、詳しくは解説しません。GitHub自体まだ使ったことがない方は、初心者にも分かりやすい解説に定評のある湊川あい氏によるWeb連載の「[マンガでわかるGit](https://next.rikunabi.com/journal/tag/webdesign-manga/)」や、その増補改訂版の書籍「わかばちゃんと学ぶ Git使い方入門」（シーアンドアール研究所より2017年刊行）などに目を通して、まずはそれらの使い方を把握しておいて下さい。

ここから先の内容は、名前を挙げた参考資料で解説されている内容を一通り把握していることを前提とします。まだ把握できていない方は、この節は一旦読み飛ばすか、流し読み程度にとどめて、準備ができたときにまた読み返すようにしてください。


## マージされやすいプルリクエストにしよう

### 変更の意図をきちんと説明しよう

OSS Gateワークショップは、まだOSSにフィードバックをした事がない人に「不具合や要望を報告する過程を体験する」という事を目標にしています。しかしOSS開発に参加してみたいという人の中には、「実際にコードを書く事を通じて参加したい」という思いが強い人もいるでしょう。また、「英語の読み書きは苦手だけれどもコードなら書ける」ということで、英語で長々と説明するよりも端的にコードの提供だけで済ませたい人もいると思います。筆者もそのように考えていましたし、今でもいきなりプルリクエストを送るという場面は度々あります。

ただ、何の説明もないプルリクエストだけが単発で送られてきても、開発者は戸惑います。仮に1行だけの変更であっても、その変更が何を意図していてどういう影響があるのか、ぱっと見で分からないからです。

「開発者なんだからプロジェクトの隅々まで100%完璧に把握してるはずだろう、だったら説明なんかしなくてもコードを見れば分かるはずだ」と思いますか？　残念ながら、それは過剰な期待というものです。*開発者といえど、ある程度以上の複雑さを持ったソフトウェアでは、どの変更がどこにどういう影響を与えるのかを一目で判断するのは難しいです*。変更が予想外の場所で不具合を引き起こす「後退バグ」が起こったり、後退バグの早期検出を図る「回帰テスト」があったりするのは、そのためです。

開発者がプルリクエストの内容をスムーズに理解し、レビューやマージするかどうかの判断を迅速に行えるようにするためにも、経緯や過去の議論を参照しやすいようにしておくことが望ましいです。なので、プルリクエストには*特定のイシューの番号（もしくはURL）を添えて「これを修正するための変更です」という説明を加える*（英語では「This fixes the issue #12345.」）のが一般的です。

イシューと紐付けないでプルリクエストをいきなり出すのであれば、そのプルリクエストの説明として、「修正したい現象の再現手順」「実際に得られた結果」「期待される結果」を説明し、その変更が「期待される結果」を得られるようにするためのものだ、という情報を添えるのが望ましいです。つまり、イシューと同等の情報量が必要ということで、結局やることは変わりません。

### 議論の余地が無い変更なら、プルリクエストから始めてもいい場合はある

動作そのものに影響がなく、是非の議論の余地が無い変更の場合、イシューを経ずにプルリクエストから始めても問題無いことがあります。例えば以下のようなケースです。

* ローカルな変数名やプライベートな関数名の綴り間違いの修正
* 言語リソースの誤訳の修正
* 言語リソースの未翻訳部分に対する訳文の追加
* Webサイトやドキュメントの誤記の修正
* Webサイトやドキュメントのリンク切れの修正

こういうものは「再現手順」「実際に得られた結果」「期待される結果」の枠に当てはめにくいので、イシューを立てようと思うと逆に難しいです。実際のプロダクトやドキュメントに残る形でフィードバックをしたいという思いが強い場合には、こういったものから手を着けてみるのもよいかもしれません。

GitHub上では、ログイン済みの状態でファイルの個別のページを表示すると、オンラインで編集を開始できます。他人のリポジトリだった場合、変更を保存するタイミングで自動的に自分のアカウント配下にフォークが作られて、プルリクエストの作成画面になります。GitLabやBitBucketなどのサービスでも、操作の順番は多少異なりますが、同様のことができます。

（スクリーンショット：編集→プルリクエストの作成画面 の様子）

ただ、変更時に意図せず混入してしまった文法エラーによって、その変更をマージすると初期化に失敗して起動できなくなってしまったり、ドキュメントのレイアウトが崩れてしまったり、というようなケースはあります。筆者が公開しているFirefox用アドオンにおいても、日本語と英語以外の翻訳リソースを提供してもらえることがありますが、文法エラーが残ったままの状態でマージしてしまって、自分の手元の環境で突然動かなくなって焦った、ということが度々ありました[^auto-lint]。Webサイト上からのファイル編集でプルリクエストした場合などには事後的にでもよいので、*どんな変更であっても、必ず一度は自分の手元で動かして（表示して）みて、問題が無いかどうかを確認するようにしましょう*。

[^auto-lint]: そのため現在は、コミットやマージの際に自動的に文法チェックを行うような設定をしていて、マージ前にそれらのミスに気付けるようにしています。

また、*変数名・関数名・API名といった、動作に影響を与える部分の誤記の修正は、特に慎重に行う必要があります*。ローカル変数やプライベートなメソッド・関数は、他から参照されないため、変更しても動作が壊れることはあまりありません。しかし、グローバルな変数や公開のメソッド、モジュール名自体の誤記は、下手に変更すると動作を壊してしまうことがあります。また、一見するとプライベートな変数や関数であっても、コード片単位でのインクルードや、メタプログラミングによって実行時に外部から参照されるなどのことによって、変更が思わぬ所に影響を及ぼしてしまうリスクがあります。実行可能なコードに関わる変更は、原則として、GitHubなどのサイト上から編集して直接プルリクエストするやり方を取らずに、手元で動作に問題が無いことを確認してからプルリクエストを出すようにすることを強くお勧めします。

なお、プロジェクトメンバー間での対面での相談やチャットなど別の場所で既に議論が尽くされていて、後はコードを変更するだけであるという場合に、傍目からは「急にプルリクエストが行われて、何故かすぐにマージされた」という見え方になる場合もあります。これは経緯を知らない人には区別が付かないので、注意が必要です。「あっちはすぐにマージしてるのに、なんでこっちは放ったらかしにされるんだ！」と思うようなケースに遭遇した場合でも、「ならば自分も」と短絡的には考えないようにしましょう。

### 「馴染むコード」を書こう

きちんとイシューに紐付けたプルリクエストなのに、何カ所も指摘が付いて、なかなかマージしてもらえない……という場合、そもそもその変更内容が*元のコードに馴染んでいない*可能性があります。

理想的なプルリクエストは、「元々の開発者が書いていたら、きっとこう書いていただろう、と思える」「後からコード全体を通して見ても、どこが元の開発者の手による箇所で、どこがプルリクエストで変更された箇所か、見分けが付かない」というものです。技術力があまりに違いすぎると、加えた変更が「馴染まないコード」として悪目立ちしてしまいがちです。

「ということは、元々の開発者と同じレベルの技術力が無いとプルリクエストしちゃ駄目ってことなのか！」と思ってしまうかもしれませんが、それはちょっと早計です。

確かに、まったく新しいモジュールを追加するような変更になると、そのレベルで「馴染むコード」を書くには、元の開発者と同等の技術力が必要になってくるでしょう。ですが、「既存のモジュールの、特定の関数の中だけの変更」というように限定的な場面であれば、スーパーエンジニアでなくても「馴染むコード」は書けます。

というのも、多くのOSSでは、全体に渡って超絶技巧が凝らされているわけではありません。心臓部になるような部分は別としても、*部分部分だけを取り出して見れば、特に末端ほど、どこにでもあるようなごく普通のコードになっています*[^importance-of-readability]。考えてみれば当たり前の話で、「ボタンがクリックされた時の動作の定義の仕方」だったり「ファイルの読み込み方」だったり、そういったものは誰がどう書いても同じにしかなりようがないですよね。

[^importance-of-readability]: そもそも、OSSで「難解で分かりにくいコード」を書くのは、開発者にとっても自殺行為です。性能的な問題とならない限りは、なるべく可読性の高いコードにしてメンテナンス性を高く保っておかないと、開発者自身が後々困ることになります。

皆さんがOSSのソースコードを前にしてたじろぐのは、どこに何があるのか分からない状態の物がたくさん積み重なっているせいで、一つの「何か巨大なスゴイ物」に見えているからでしょう。近付いてよく見てみれば、「どこかで見たことがあるような書き方だ」と感じる箇所がそこかしこに見つかるはずです。

慣れないうちは、コードの変更に取り組むときは、部分部分で見た時に「これなら自分でも理解できる」という範囲で取り組むようにしましょう。少し背伸びして「ちょっと難しいかも……」という課題に取り組むのは、簡単な課題の解決で自信を付けてからにすることを、筆者としてはおすすめします。

### コラム：「Good First Issue」から始めるフィードバック

本書では基本的に「自分が遭遇したつまずきを報告する」という流れでのフィードバックを推奨しています。しかし、まだ何もつまずいていないものの、自分が普段からお世話になっている有名なOSSの開発に参加してみたい、問題解決に取り組んだりプルリクエストを出したりしてみたい、という人もいるかもしれません。あるいは、つまずいた問題が大きすぎて、自分には手に負えない、という場合もあるかもしれません。

そういう人は、そのプロジェクトのイシュートラッカーで「Good First Issue」や「Good First Bug」などとタグ付けされたイシューを探してみるとよいかもしれません。規模の大きなプロジェクトで、プロジェクトに協力してくれる人を随時募っている場合には、新規のプロジェクト参加者が挑戦するのにちょうどいい難易度の課題に、そのようなタグが付けられている場合があります。

取り組めそうな課題を見つけたら、「これに挑戦します」と宣言するコメントを追加して、進捗状況を随時共有しながら取り組んでみるとよいでしょう。分からないことがあったら、質問をするとプロジェクトに参加中の先達からアドバイスをもらえるかもしれません。


## コードを書き始める前に、まず読もう

### コードを馴染ませる技術

前述した通り、プルリクエストの理想は「元のコードに馴染む、まるで元の開発者が書いたかのように見えるコード」です。しかし、いわゆる「技術力」さえあればそれができるかというと、筆者はそうは思いません。

そもそも、「技術力」という言葉の指す対象は幅広いです。問題解決力・発想力・実装力などの技術力は主に実装に関わる物ですが、「馴染むコード」を書くために必要なのは、注意力・観察力・理解力・模倣力といった、全く別カテゴリの技術力です。なので、ものすごく実装力の高い人でも、元のコードからすると全く異質なプルリクエストをしてしまう、ということは十分にあり得ます。







### どんなコードが書かれているかを知らないと、馴染むコードは書けない

「リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック（Theory in practice）」（オライリージャパンより、2012年刊行）



の問題だと筆者は考えています。ある場面でAを選ぶかBを選ぶか、元の開発者がどういう選択をしたのかをよく見て、それに倣ったコードを書くというのが、「馴染む変更」を行う上での重要なポイントです。

ただ、「そこに選択があった」ということ自体に気が付くためには、ある程度の知識や経験が必要になってきます。







Supershipさまで「既存のコードを変更するノウハウ」を学ぶ研修を行いました - ククログ(2018-11-12)
https://www.clear-code.com/blog/2018/11/12.html


# 既存のコードを変更する時の流れ

 1. 変更対象のコードを把握する
 2. 変更の計画を立てる
 3. 自動テストを書く
 4. 実際に変更を行う

# 実際には

 1. **変更対象のコードを把握する**
 2. 変更する
    1. 変更の計画を立てる
    2. 自動テストを書く
    3. 実際に変更を行う

# つまり

*変更対象のコードを把握する事*
のウェイトが非常に大きい。



*周囲のコードに*
*馴染むコード*
を書く



# 理想的な仕上がりの「変更」

 * 現在は、この機能がない・こういう問題がある
 * 機能があったとしたら・問題がなかったとしたら、*当然*こう書かれているはずだろう
   （元々作った人が実装していたら、当然こう実装されていただろう）

# それをするためには？

 * 元作者になりきる
 * 前提知識を共有した
   *チームの一員*になる

# 馴染むコードにするために

 * *コーディングスタイル*を合わせる
 * *設計方針*を合わせる
 * *背景事情*に合わせる

# つまり、読み取るべき情報は

 * コーディングスタイル
 * 設計方針
 * 背景事情

どういう所を見ればそれらが分かる？


 * *コーディングスタイル*
 * 設計方針
 * 背景事情

# コーディングスタイル

 * コード全体
 * スタイルガイド、コーディング規約（ある場合）

# コーディングスタイルの例

 * 命名規則
 * スペースの空け方、詰め方
 * 改行の入れ方
 * 「この機能は使わない」
   「この書き方はしない」


# 命名規則1

 * *C*lass*N*ame （Pascal Case / Upper Camel Case）
 * variable*N*ame （Camel Case / Lower Camel Case）
 * variable*_*name （Snake Case）
 * file*-*name （Kebab Case / Chain Case）
 * CONSTANT_NAME （すべて大文字）

# 命名規則2

 * String#include
   （原形）
 * String#include*s* 
   （三人称単数形）
 * items（複数形）
 * itemArray（単数形）

# 命名規則3

よく使われるネーミング

 * *is*Multiple / *has*Item
 * *get*Name / *set*Name
 * *fetch*Data
 * valid*?* / save*!* (ActiveRecord)


# 「map」か「collect」か

```ruby
results = items.map {|item| ... }
results = items.collect {|item| ... }
```

# 「こう書く事もできる」

 * 色々な書き方ができる≠色々な書き方をしていい
 * どの書き方でもいいので、*統一する事*が大事
 * 迷ったら有名プロジェクトのコーディングスタイルをそのまま採用

# 良いコードと馴染むコードは別

 * リーダブルコードなどで
   「これは冗長」「おすすめしない」
   とされているスタイルが
   採用されている場合もある
 * 「馴染むコードを書く事」と
   「よりリーダブルなコードに直す事」
   は別の作業と考えよう



# 設計方針を読み取る

 * ディレクトリ構成を見る
 * 自動テストを読む
 * コードの流れを追う
   * 初期化処理から
   * 「この機能を調べたい」と
     決めた部分から

# ディレクトリ構成

「この機能を変更するときは
*このあたり*を探せば
ファイルが見つかる*はず*」

という判断に必要な情報

# モジュールの設計上の分類でまとめるのか？

# アプリケーションとしての機能単位でまとめるのか？



# 自動テスト

 * TDD（test）形式？
 * BDD（spec）形式？

形式の違いよりも
*中身*の方に注目しよう

# テストの「テスト」以外の意義

 * 自動テストは*各モジュールの*
   *実際の使い方のサンプル集*
   である
 * モジュールの実装を見るより、
   テストを見た方がよく分かる

# テストの例

# テストから読み取れる設計方針

 * モジュールの分け方
 * モジュール同士の連携のさせ方


同じプロダクトの中でも、Modelの中とControllerの中など文脈によっても視点が変わってくる

# モジュール同士の連携の様子の見方

 * どのような順番で初期化するのか？
 * 必要な情報を外部からどうやって与えるのか？

を見よう

# コードの流れを追ってみる

 * 初期化処理から・呼び出し元から順に流れを追う
 * 目に見えている情報から逆順に処理の流れを追う


# 設計を「合わせる」という事

 * *今の自分が*分かりやすいかどうかではなく、*次にコードを変更する人が*分かりやすいかどうか
 * 「欲しい物は、一般的な傾向に従って探せば見つかる」という状態を維持する事が大切








コーディングスタイルを合わせる
他のコードに合わせる
指摘を受けたら直す
丁寧なプロジェクトでは、ビルド手順の中にコーディングスタイルのチェックの仕方が書いてあることもある
前章の例の「プロジェクトオーナーの普段の作業環境と異なる作業環境への対応」でやっているように、コードフォーマッターを常に通すようにするようなフィードバックをしてもいい。

コーディングスタイルを変えるだけの変更、はリジェクトする方針のプロジェクトもある。
Railsなど。
そういう場合、他の変更の中でシレッとやることになる。




名前付けを合わせる。
「リーダブルコード」などで「こういう書き方をすると読みやすい」という例がいくつも紹介されているが、そういう中でどの書き方を選ぶか？　というところに個性が出る。
例えば

n_items
itemsCound


設計を合わせる。モジュールの分割の粒度を揃える。
APIのデザインを合わせる。
引数の流儀を合わせる。



コミットログの書き方を揃える。
コミットメッセージに*有用な情報*を含めておかないといけない
 * 「ユーザーがグループに所属していない時にログインに失敗する問題を修正」
 * 「チケットの作成時に空のフィールドを許容しないように変更」
5W1Hのうちの「Why」
# いいかげんなコミットメッセージはログの有用性を損なう
 * 「バグ修正」
 * 「テスト」
 * 「腹減った」



変更を分ける。
複数の変更を一度に投げない。






OSS初心者がつまづきながらOSSマナーを学んでいく話 - Speaker Deck
https://speakerdeck.com/fuqda/osschu-xin-zhe-gatumadukinagaraossmanawoxue-ndeikuhua-4edf8e12-a019-4fa6-bc93-5be40a788e86

OSSで結果を出す方法 - Speaker Deck
https://speakerdeck.com/knu/ossdejie-guo-wochu-sufang-fa?slide=3

このあたりで語られているような内容。








## テストを直してみよう

### テストを実行してみよう

プルリクエストの中でもあまり議論の余地なく受け入れてもらいやすい物に、「自動テストの修正[^what-is-automated-test]」があります。

[^what-is-automated-test]: 自動テストとは、「テストの手順、実測値、期待値」の3つを定義しておき、手順の実行結果の実測値が期待値と異なっていればテスト失敗の旨を教えてくれる、というプログラムのことを言います。最も単純な例では、ある関数を引数を変えながら何度か呼び、関数の戻り値が想定通りかどうかを比較して、一致していれば成功、不一致なら失敗とする、といった要領です。

プロジェクトによっては、説明文の中にテストの実行手順が書かれている場合があります。その場合、*ソースコードをダウンロードしたら、まずはテストを実際に動かしてみましょう*。

実行手順が書かれていないけれどもテストらしきファイル（`test`や`tests`と名付けられたフォルダー）があるという場合、ソフトウェアの種類によっては、一般的なテストの実行手順を適用できる場合があります。例えば、Node.jsのnpmのモジュールなら`npm install && npm run test`、RubyのGemなら`bundle install && bundle exec rake test`といったコマンド列を端末上のシェルで実行する方法が一般的です。

テストの実行手順がどうしても分からない場合は、「実行手順が説明に書かれていないので、テストを実行できない」ということ自体をイシューとして報告してみましょう。また、うまくテストを実行できたら、その手順を説明に追加するプルリクエストを出すようにしましょう。そうすることで、次以降に同じ所でつまずく人が減ります。

### 失敗しているテストを直そう

自動テストは、基本的にはすべて成功する状態になっていることが期待されます。しかし、プロジェクトによっては、自動テストが失敗する状態になっていることがあります。開発者がそのことに気付いていない場合もありますし、気付いていてあえて放置している場合もあります。いずれにしても、*自動テストの失敗は、開発者の手が回っていないということの表れ*ですから、今まさにコントリビュートが望まれている状態だと言えるでしょう。テストがすべて成功する状態に修正するプルリクエストは、開発者も大抵は喜んでマージしてくれるはずです。

自動テストの壊れ方には、「実装の方が壊れている場合」と「テストの方が壊れている場合」の2種類があります。実装の方が壊れているとは、つまり、後退バグが発生しているということです。テストの方が壊れているとは、実装が変化したり[^test-fail-from-updated-implementation]実行環境の事情が変わったりした[^test-fail-from-updated-environment]にもかかわらず、自動テストの方にそれが反映されていない、ということです。放置されていることが多いのは後者のパターンでしょう。というのも、後者の状態でも通常の使用そのものには支障はないからです。

[^test-fail-from-updated-implementation]: 例えば、「関数に機能が追加されて引数の数が2つから3つに増えたにもかかわらず、テストでは引数を2つしか渡していない」「関数の戻り値の種類が整数から小数に変わったのに、テストでは小数が返ってくることを想定していない」などのような場合。
[^test-fail-from-updated-environment]: 例えば、「実験的に導入されていた演算子をテストで使っていたが、実行環境が更新されてその演算子が廃止された」「テストで使っていた組み込みのクラスが、その言語の新しいバージョンでは廃止された」などのような場合。

自動テストはそのOSSの「期待される動作」「詳細な使い方」を説明するものでもあります。テストを熟読しながら、なぜテストが失敗しているのか原因を調べて、すべて成功する状態に修正する、という作業をすると、確実にそのOSSへの理解が深まります。OSSでテストの失敗に遭遇したら、是非挑戦してみて下さい。







## 悪いフィードバック：プロジェクトの背景を踏まえないハックの提案

筆者も、過去に強引な実装のパッチを代理で投稿してもらった事がありましたが、実装の筋が悪すぎたためか、それ以上話が進む事はありませんでした。

[61846 - Undockable My Sidebar - in a new window](https://bugzilla.mozilla.org/show_bug.cgi?id=61846)










## 何をしても駄目なときは

### フォークするしかない？　無闇にフォークしちゃ駄目？

問題を再定義して、プロジェクトのスコープに収まるようにして、筋の良い実装も用意して、それでも要望を受け入れてもらえない、ということはあります。最終的に要望を受け入れるかどうかは、そのプロジェクト内部の人が決定することです。外部から協力するだけの立場の人には、残念ですがその判断への介入はできません。

そういうときに、外部協力者の立場で取れる最後の手段が、プロジェクトのフォークです。設定されているライセンスの条件に従う限り、誰もが自由にそのOSSを改造し、再配布することができます。プルリクエストのために一時的にフォークするのではなく、改造の成果を元の開発プロジェクトに還元しないまま独立したプロジェクトとして継続する、という選択肢です。

リソースの無駄な分散を防ぐためにも、ユーザーの混乱を避けるためにも、*フォークは可能な限り避けるのが望ましい*です。どうしてもフォークする場合は、それ以後の開発やメンテナンスに要するすべてのリソースを自前でまかない、最後までそのソフトウェアの面倒を見続ける覚悟が必要です。

そのため、大きなOSSプロジェクトほど、フォークは珍しいです。近年で観測された大きなフォークといえば、WebKitからGoogleがフォークして始めたBlinkのように、フォーク主体に膨大なリソースがある場合か、OpenOffice.orgからのLibreOfficeya
ownCloudからのNextcloudのように、フォーク元の主要開発者達が何らかの理由で元プロジェクトから離反して、フォーク先にそのまま合流した場合くらいでしょう。

Firefox 28からフォークしたPale Moonや、Firefox 56からフォークしたWaterfoxのように、個人や少人数のグループが大規模なプロジェクトをフォークしたケースは、健全な状態を保ち続けられていないことが多い、という印象が筆者にはあります[^forked-gecko]。「フォークしたはいいものの、実際やってみたら意外と大変で、しばらくしたら更新が滞ってしまいました」というのは、ユーザーに過剰な期待を持たせた挙げ句に振り回してしまう、最悪の結末です。

[^forked-gecko]: これらのフォーク版は、フォーク以後のFirefoxで行われた性能向上や安全性向上のための抜本的な変更、最新のWeb技術への対応などが反映されておらず、最新のFirefoxと比べるとだいぶ見劣りする状態になっています。

### いざというときの選択肢として

しかし、そうは言っても「絶対にフォークしてはならない」というわけでもありません。

上述のとおり、プロジェクトの運営主体を完全に引き継いで責任を持って継続できそうなのであれば、あるいは、フォーク版を自分しか使わなくて不利益はすべて折り込み済みなのであれば、フォークは選択肢の一つとして考慮する価値があります。

実際に筆者にも、元プロジェクトには絶対に取り込んでもらえない独自の機能が、どうしても切実に業務上必要だという理由で、他の人の開発したOSSをフォークして以後、ニーズに応じて回収を続けながら10年近く維持し続けている[実例](https://github.com/clear-code/flex-confirm-mail/)があります。

「いざとなったらフォークして続けられる」という点は、OSSの強みです。もしフォークという手段が許されていなければ、やりたいビジネスを諦めたり、自分の使い方での致命的な不便を強いられたりしなくてはなりません。*覚悟と努力次第で困難を乗り越えられる余地が常に残されている*ということに筆者は安心感を覚え、逆に、プロプライエタリな製品には「これ、いつまで使い続けられるんだろう？」と不安を覚える、というのは、誇張ではなく実際の思いです。

「そんなタフな選択ができるのは、あなた（筆者）がスーパーエンジニアだからだ」と思われるでしょうか？　いいえ、そんなことはありません。筆者のOSS開発者としてのキャリア自体、他の人が開発を放棄して動かなくなってしまったソフトウェアを、再び動くように見よう見まねで修正したところから始まっています[^fork-of-non-free-software]。当時の筆者はオブジェクト指向もロクに分かっていないようなド素人でした。その元ソフトウェアはごく単純な物でしたが、それでも当時の筆者にとっては、全貌を理解しきれない、手に余る代物としか思えませんでした。

[^fork-of-non-free-software]: 実を言うと、このときフォークの元にしたソフトウェア（Mozilla Application Suiteのコンテキストメニュー拡張機能）にはオープンソースライセンスが設定されていませんでした。自分の記憶が正しければ、元の作者の方が「習作のような物なので権利は主張しない」という旨のことをおっしゃっていたため、パブリックドメイン扱いとして、こちらでオープンソースなライセンスを設定したという経緯だったように思います。

しかし、動かなくなっていた原因箇所をどうにか直して動く状態に戻せたことで、筆者はそれを足がかりとして学習を進められました。当時の筆者にとっては、入門書に書かれていた内容（基本中の基本）と自分のやりたかった事（高度なGUIを持つソフトウェア）との間のギャップが大きすぎて途方に暮れていましたが、「すでに動く状態のソフトウェア」のソースコードを読むことによって、「そうか、こういう機能を作りたいときはこういう書き方をするんだ」という実践的な知識を得ていけたのでした。

また、ソフトウェアの公開の仕方、継続的なメンテナンスの仕方、要望の受け答えの仕方など、コーディングそのものとは異なる周辺領域の様々な経験についても、そうして「自分のプロジェクト」を持つようになって以降、必要に迫られて身に着ける形で、非常に多くのものを得られました。

本書は「OSSへのフィードバックの仕方」を解説していますが、実際の所、*良いフィードバックとは「プロジェクトオーナーが受け取って嬉しいと思えるフィードバック」の一言に尽きます*。どうだったら嬉しいのかということは、プロジェクトオーナーの立場を経験してみるとよく分かる部分が多々あります。そういう機会になるという意味で、皆さんもフォークをきっかけに「自分のプロジェクト」を持ってみてはいかがでしょうか？
