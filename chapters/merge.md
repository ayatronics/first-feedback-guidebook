# プルリクエスをマージしてもらえない！

イシューが却下されることがあるように、プルリクエストもマージに至らず却下されることがあります。頑張ってプルリクエストしてみてもなかなかマージしてもらえないという場合、もしかしたら頑張り所を間違えているのかもしれません。


## コードをよく読もう

### どんなコードが書かれているかを知らないと、馴染むコードは書けない

前述した通り、プルリクエストの理想は「元のコードに馴染む、まるで元の開発者が書いたかのように見えるコード」です。前章では「技術力に差がありすぎると変更箇所が悪目立ちする」と述べましたが、技術力があっても変更箇所が悪目立ちすることはあります。筆者の経験上は、「そもそも馴染ませようという気があるか、ないか」という所での差異が大きいような印象があります。

他の箇所に馴染むような変更をするためには、「他の箇所」がどういう書かれ方になっているかを把握していないといけません。つまり、*変更対象の既存のコードをちゃんと読む*必要がある、ということです。

既存のコードを読むと、

* 変数や関数の名前の付け方の傾向
* モジュールの分割の粒度の傾向
* 全体的な設計方針、設計思想
* コメントに書かれた補足情報

などなど、色々なことが読み取れます。しかし、本を読むように漫然と先頭から読んでも、内容が頭に入ってこない場合が多いでしょう。それもそのはずです、ソースコードはそのように読むようには書かれていません。ソースコードを読むには、読み方を知る必要があります。

### コードの語彙力、表現の知識を身に付けよう

文章を読むときには、文法に対する理解だけでなく、単語や慣用句の知識（語彙力）も必要です。同じことがコードを読むときにも言えます。「こういうことをしたい時に、こういう書き方をする」「こういう効果を狙って、こういう書き方をする」という「コードの語彙力」があると、同じコードを読んで得られる情報の量が大きく増えます。コードを読むときの意識の解像度が上がる、と言った方がよいかもしれません。

特にポピュラーな表現のパターンを、以下にいくつか挙げてみましょう。

複数の単語からなる識別子の名前付けには、以下のようなパターンがあり、それぞれよく使われる場面があります。

* *S*omething*N*ame：各単語の先頭1文字を大文字にする。Pascal Case、またはUpper Camel Caseと呼ばれる。クラス名で使われることが多い。
* something*N*ame：2つ目以降の単語の先頭1文字を大文字にする。Camel Case、またはLower Camel Caseと呼ばれる。
* something*_*name：単語同士をアンダースコアで連結する。Snake Caseと呼ばれる。
* something*-*name：単語同士をハイフンで連結する。ケバブケース、チェインケース、ハイフンケースなどと呼ばれる。ファイル名で使われる。
* SOMETHING_NAME：単語をすべて大文字にして連結する。定数でよく使われる。

複数のデータを保持する変数の名前付けにもいくつかのパターンがあります。

* item*s*などの、データの内容を表す単語の複数形
* item*Array*、item*List*などの、データの内容＋データを保持している構造を表す接尾辞

個数、件数などの「数」を保持する変数やプロパティの名前付けには以下のようなパターンがあります。

* item_*count*
* item_*length*
* item_*size*
* *n*_items（数学や物理で「N個の」といった言い方をすることにちなむ表現）

関数名・メソッド名の動詞にもパターンがあります。例えば、原形にするか現在形にするかは、何をさせる機能かという目的で変わることが多いです。

* String#split（分割する）などの原形：データに変更を加える、何かをさせるとき。
* String#include*s*（部分文字列を含むかどうか）などの三人称単数形：データの状態を問い合わせ、真偽値で結果を返すとき。

特定の文脈で使われやすい単語や表現にもいくつかの流儀があります。状態を問い合わせる場面では、以下のような例があります。

* *is*Item / *has*Item：Yes/Noで答える疑問文のように名付ける。
* *get*Item*State*：状態を尋ねる、という趣旨をそのまま名前に採用する。
* valid*?*：Ruby on Rails（のActiveRecord）に見られるパターンで、真偽値を返す場合の接尾辞として「?」を使う。

データの取得や保存に関わる場面

* *get*Item / *set*Item：値を取得したり変更したりする物について、set-getのペアで名付ける。
* *fetch*Item / *download*Item / *push*Item / *upload*Item ：データをネットワーク越しに取得・保存する場合に、そのことを強調するように名付ける。
* save*!*：Ruby on Rails（のActiveRecord）に見られるパターンで、破壊的な操作をしたり、操作を強行したりする場合の接尾辞として「!」を使う。

同じことを表現する書き方に複数の流儀がある場合、そのOSSではどの流儀に従っているのかを把握して、流儀を合わせることが大事です。*それぞれの流儀のメリットの多寡よりも、そのOSSの中で流儀が統一されているかどうかの方が、コードの読みやすさや開発の効率に与える影響が大きい*からです。

また、変数や関数の名前付けといったミクロな部分だけでなく、モジュールの設計というマクロな部分にも、いろいろな流儀があります。設計の流儀でよく知られているのは、「デザインパターン」です。以下のような名前付けを皆さんも見たことはないでしょうか？

* Singleton
* Observer
* Iterator

デザインパターンは、複雑な問題に対処するときの典型的な設計パターンとしてよく使われています。例を交えての解説もすでに世の中に多数存在するので、本書では特に掘り下げませんが、これらのデザインパターンを学んでおくと、コードを読むときに「あ、これは○○パターンだ！」と知識を当てはめられるので、*見通しがよくなり、理解が進みやすくなります*。









これに関して、筆者は以前に業務で、[新入社員の方向けの「既存のコードを変更するノウハウ」を学ぶ研修を主導させていただいたことがあります](https://www.clear-code.com/blog/2018/11/12.html "研修を行いました - ククログ(2018-11-12)")。本節の内容はこの研修の内容を元に、一部を抜粋した形でお送りします。

言語を問わず一般的に良いコードの書き方について、特に「読みやすさ」という観点から解説を加えた本に、「リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック（Theory in practice）」（オライリージャパンより、2012年刊行）があります。この本を読んでからOSSのコードを読むと、「あっ、この書き方は読みやすさのための工夫をしている！」という箇所、プロジェクト内でどのような流儀を採用しているかに、気が付けるようになるでしょう。そうすると、変更箇所にも同じ流儀を適用しやすくなるはずです。



# ディレクトリ構成

「この機能を変更するときは
*このあたり*を探せば
ファイルが見つかる*はず*」

という判断に必要な情報

# モジュールの設計上の分類でまとめるのか？

# アプリケーションとしての機能単位でまとめるのか？



 * モジュールの分け方
 * モジュール同士の連携のさせ方


# モジュール同士の連携の様子の見方

 * どのような順番で初期化するのか？
 * 必要な情報を外部からどうやって与えるのか？

 * 初期化処理から・呼び出し元から順に流れを追う
 * 目に見えている情報から逆順に処理の流れを追う


 * *今の自分が*分かりやすいかどうかではなく、*次にコードを変更する人が*分かりやすいかどうか
 * 「欲しい物は、一般的な傾向に従って探せば見つかる」という状態を維持する事が大切






設計を合わせる。モジュールの分割の粒度を揃える。
APIのデザインを合わせる。
引数の流儀を合わせる。



コミットログの書き方を揃える。
コミットメッセージに*有用な情報*を含めておかないといけない
 * 「ユーザーがグループに所属していない時にログインに失敗する問題を修正」
 * 「チケットの作成時に空のフィールドを許容しないように変更」
5W1Hのうちの「Why」
# いいかげんなコミットメッセージはログの有用性を損なう
 * 「バグ修正」
 * 「テスト」
 * 「腹減った」



## 周辺事情も調べてみよう

過去に却下された提案



## 悪いフィードバック：プロジェクトの背景を踏まえないハックの提案

筆者も、過去に強引な実装のパッチを代理で投稿してもらった事がありましたが、実装の筋が悪すぎたためか、それ以上話が進む事はありませんでした。

[61846 - Undockable My Sidebar - in a new window](https://bugzilla.mozilla.org/show_bug.cgi?id=61846)







OSS初心者がつまづきながらOSSマナーを学んでいく話 - Speaker Deck
https://speakerdeck.com/fuqda/osschu-xin-zhe-gatumadukinagaraossmanawoxue-ndeikuhua-4edf8e12-a019-4fa6-bc93-5be40a788e86

OSSで結果を出す方法 - Speaker Deck
https://speakerdeck.com/knu/ossdejie-guo-wochu-sufang-fa?slide=3

このあたりで語られているような内容。














## 何をしても駄目なときは

### フォークするしかない？　無闇にフォークしちゃ駄目？

問題を再定義して、プロジェクトのスコープに収まるようにして、筋の良い実装も用意して、それでも要望を受け入れてもらえない、ということはあります。最終的に要望を受け入れるかどうかは、そのプロジェクト内部の人が決定することです。外部から協力するだけの立場の人には、残念ですがその判断への介入はできません。

そういうときに、外部協力者の立場で取れる最後の手段が、プロジェクトのフォークです。設定されているライセンスの条件に従う限り、誰もが自由にそのOSSを改造し、再配布することができます。プルリクエストのために一時的にフォークするのではなく、改造の成果を元の開発プロジェクトに還元しないまま独立したプロジェクトとして継続する、という選択肢です。

リソースの無駄な分散を防ぐためにも、ユーザーの混乱を避けるためにも、*フォークは可能な限り避けるのが望ましい*です。どうしてもフォークする場合は、それ以後の開発やメンテナンスに要するすべてのリソースを自前でまかない、最後までそのソフトウェアの面倒を見続ける覚悟が必要です。

そのため、大きなOSSプロジェクトほど、フォークは珍しいです。近年で観測された大きなフォークといえば、WebKitからGoogleがフォークして始めたBlinkのように、フォーク主体に膨大なリソースがある場合か、OpenOffice.orgからのLibreOfficeya
ownCloudからのNextcloudのように、フォーク元の主要開発者達が何らかの理由で元プロジェクトから離反して、フォーク先にそのまま合流した場合くらいでしょう。

Firefox 28からフォークしたPale Moonや、Firefox 56からフォークしたWaterfoxのように、個人や少人数のグループが大規模なプロジェクトをフォークしたケースは、健全な状態を保ち続けられていないことが多い、という印象が筆者にはあります[^forked-gecko]。「フォークしたはいいものの、実際やってみたら意外と大変で、しばらくしたら更新が滞ってしまいました」というのは、ユーザーに過剰な期待を持たせた挙げ句に振り回してしまう、最悪の結末です。

[^forked-gecko]: これらのフォーク版は、フォーク以後のFirefoxで行われた性能向上や安全性向上のための抜本的な変更、最新のWeb技術への対応などが反映されておらず、最新のFirefoxと比べるとだいぶ見劣りする状態になっています。

### いざというときの選択肢として

しかし、そうは言っても「絶対にフォークしてはならない」というわけでもありません。

上述のとおり、プロジェクトの運営主体を完全に引き継いで責任を持って継続できそうなのであれば、あるいは、フォーク版を自分しか使わなくて不利益はすべて折り込み済みなのであれば、フォークは選択肢の一つとして考慮する価値があります。

実際に筆者にも、元プロジェクトには絶対に取り込んでもらえない独自の機能が、どうしても切実に業務上必要だという理由で、他の人の開発したOSSをフォークして以後、ニーズに応じて回収を続けながら10年近く維持し続けている[実例](https://github.com/clear-code/flex-confirm-mail/)があります。

「いざとなったらフォークして続けられる」という点は、OSSの強みです。もしフォークという手段が許されていなければ、やりたいビジネスを諦めたり、自分の使い方での致命的な不便を強いられたりしなくてはなりません。*覚悟と努力次第で困難を乗り越えられる余地が常に残されている*ということに筆者は安心感を覚え、逆に、プロプライエタリな製品には「これ、いつまで使い続けられるんだろう？」と不安を覚える、というのは、誇張ではなく実際の思いです。

「そんなタフな選択ができるのは、あなた（筆者）がスーパーエンジニアだからだ」と思われるでしょうか？　いいえ、そんなことはありません。筆者のOSS開発者としてのキャリア自体、他の人が開発を放棄して動かなくなってしまったソフトウェアを、再び動くように見よう見まねで修正したところから始まっています[^fork-of-non-free-software]。当時の筆者はオブジェクト指向もロクに分かっていないようなド素人でした。その元ソフトウェアはごく単純な物でしたが、それでも当時の筆者にとっては、全貌を理解しきれない、手に余る代物としか思えませんでした。

[^fork-of-non-free-software]: 実を言うと、このときフォークの元にしたソフトウェア（Mozilla Application Suiteのコンテキストメニュー拡張機能）にはオープンソースライセンスが設定されていませんでした。自分の記憶が正しければ、元の作者の方が「習作のような物なので権利は主張しない」という旨のことをおっしゃっていたため、パブリックドメイン扱いとして、こちらでオープンソースなライセンスを設定したという経緯だったように思います。

しかし、動かなくなっていた原因箇所をどうにか直して動く状態に戻せたことで、筆者はそれを足がかりとして学習を進められました。当時の筆者にとっては、入門書に書かれていた内容（基本中の基本）と自分のやりたかった事（高度なGUIを持つソフトウェア）との間のギャップが大きすぎて途方に暮れていましたが、「すでに動く状態のソフトウェア」のソースコードを読むことによって、「そうか、こういう機能を作りたいときはこういう書き方をするんだ」という実践的な知識を得ていけたのでした。

また、ソフトウェアの公開の仕方、継続的なメンテナンスの仕方、要望の受け答えの仕方など、コーディングそのものとは異なる周辺領域の様々な経験についても、そうして「自分のプロジェクト」を持つようになって以降、必要に迫られて身に着ける形で、非常に多くのものを得られました。

本書は「OSSへのフィードバックの仕方」を解説していますが、実際の所、*良いフィードバックとは「プロジェクトオーナーが受け取って嬉しいと思えるフィードバック」の一言に尽きます*。どうだったら嬉しいのかということは、プロジェクトオーナーの立場を経験してみるとよく分かる部分が多々あります。そういう機会になるという意味で、皆さんもフォークをきっかけに「自分のプロジェクト」を持ってみてはいかがでしょうか？
