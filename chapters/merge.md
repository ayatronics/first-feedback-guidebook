# プルリクエスをマージしてもらえない！

プルリクエストをしてつまずいた人




## コードをよく読もう

### コードを馴染ませる技術

前述した通り、プルリクエストの理想は「元のコードに馴染む、まるで元の開発者が書いたかのように見えるコード」です。しかし、いわゆる「技術力」さえあればそれができるかというと、筆者はそうは思いません。

そもそも、「技術力」という言葉の指す対象は幅広いです。問題解決力・発想力・実装力などの技術力は主に実装に関わる物ですが、「馴染むコード」を書くために必要なのは、注意力・観察力・理解力・模倣力といった、全く別カテゴリの技術力です。なので、ものすごく実装力の高い人でも、元のコードからすると全く異質なプルリクエストをしてしまう、ということは十分にあり得ます。







### どんなコードが書かれているかを知らないと、馴染むコードは書けない

「リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック（Theory in practice）」（オライリージャパンより、2012年刊行）



の問題だと筆者は考えています。ある場面でAを選ぶかBを選ぶか、元の開発者がどういう選択をしたのかをよく見て、それに倣ったコードを書くというのが、「馴染む変更」を行う上での重要なポイントです。

ただ、「そこに選択があった」ということ自体に気が付くためには、ある程度の知識や経験が必要になってきます。







Supershipさまで「既存のコードを変更するノウハウ」を学ぶ研修を行いました - ククログ(2018-11-12)
https://www.clear-code.com/blog/2018/11/12.html


# 既存のコードを変更する時の流れ

 1. 変更対象のコードを把握する
 2. 変更の計画を立てる
 3. 自動テストを書く
 4. 実際に変更を行う

# 実際には

 1. **変更対象のコードを把握する**
 2. 変更する
    1. 変更の計画を立てる
    2. 自動テストを書く
    3. 実際に変更を行う

# つまり

*変更対象のコードを把握する事*
のウェイトが非常に大きい。



*周囲のコードに*
*馴染むコード*
を書く



# 理想的な仕上がりの「変更」

 * 現在は、この機能がない・こういう問題がある
 * 機能があったとしたら・問題がなかったとしたら、*当然*こう書かれているはずだろう
   （元々作った人が実装していたら、当然こう実装されていただろう）

# それをするためには？

 * 元作者になりきる
 * 前提知識を共有した
   *チームの一員*になる

# 馴染むコードにするために

 * *コーディングスタイル*を合わせる
 * *設計方針*を合わせる
 * *背景事情*に合わせる

# つまり、読み取るべき情報は

 * コーディングスタイル
 * 設計方針
 * 背景事情

どういう所を見ればそれらが分かる？


 * *コーディングスタイル*
 * 設計方針
 * 背景事情

# コーディングスタイル

 * コード全体
 * スタイルガイド、コーディング規約（ある場合）

# コーディングスタイルの例

 * 命名規則
 * スペースの空け方、詰め方
 * 改行の入れ方
 * 「この機能は使わない」
   「この書き方はしない」


# 命名規則1

 * *C*lass*N*ame （Pascal Case / Upper Camel Case）
 * variable*N*ame （Camel Case / Lower Camel Case）
 * variable*_*name （Snake Case）
 * file*-*name （Kebab Case / Chain Case）
 * CONSTANT_NAME （すべて大文字）

# 命名規則2

 * String#include
   （原形）
 * String#include*s* 
   （三人称単数形）
 * items（複数形）
 * itemArray（単数形）

# 命名規則3

よく使われるネーミング

 * *is*Multiple / *has*Item
 * *get*Name / *set*Name
 * *fetch*Data
 * valid*?* / save*!* (ActiveRecord)


# 「map」か「collect」か

```ruby
results = items.map {|item| ... }
results = items.collect {|item| ... }
```

# 「こう書く事もできる」

 * 色々な書き方ができる≠色々な書き方をしていい
 * どの書き方でもいいので、*統一する事*が大事
 * 迷ったら有名プロジェクトのコーディングスタイルをそのまま採用

# 良いコードと馴染むコードは別

 * リーダブルコードなどで
   「これは冗長」「おすすめしない」
   とされているスタイルが
   採用されている場合もある
 * 「馴染むコードを書く事」と
   「よりリーダブルなコードに直す事」
   は別の作業と考えよう



# 設計方針を読み取る

 * ディレクトリ構成を見る
 * 自動テストを読む
 * コードの流れを追う
   * 初期化処理から
   * 「この機能を調べたい」と
     決めた部分から

# ディレクトリ構成

「この機能を変更するときは
*このあたり*を探せば
ファイルが見つかる*はず*」

という判断に必要な情報

# モジュールの設計上の分類でまとめるのか？

# アプリケーションとしての機能単位でまとめるのか？



# 自動テスト

 * TDD（test）形式？
 * BDD（spec）形式？

形式の違いよりも
*中身*の方に注目しよう

# テストの「テスト」以外の意義

 * 自動テストは*各モジュールの*
   *実際の使い方のサンプル集*
   である
 * モジュールの実装を見るより、
   テストを見た方がよく分かる

# テストの例

# テストから読み取れる設計方針

 * モジュールの分け方
 * モジュール同士の連携のさせ方


同じプロダクトの中でも、Modelの中とControllerの中など文脈によっても視点が変わってくる

# モジュール同士の連携の様子の見方

 * どのような順番で初期化するのか？
 * 必要な情報を外部からどうやって与えるのか？

を見よう

# コードの流れを追ってみる

 * 初期化処理から・呼び出し元から順に流れを追う
 * 目に見えている情報から逆順に処理の流れを追う


# 設計を「合わせる」という事

 * *今の自分が*分かりやすいかどうかではなく、*次にコードを変更する人が*分かりやすいかどうか
 * 「欲しい物は、一般的な傾向に従って探せば見つかる」という状態を維持する事が大切








コーディングスタイルを合わせる
他のコードに合わせる
指摘を受けたら直す
丁寧なプロジェクトでは、ビルド手順の中にコーディングスタイルのチェックの仕方が書いてあることもある
前章の例の「プロジェクトオーナーの普段の作業環境と異なる作業環境への対応」でやっているように、コードフォーマッターを常に通すようにするようなフィードバックをしてもいい。

コーディングスタイルを変えるだけの変更、はリジェクトする方針のプロジェクトもある。
Railsなど。
そういう場合、他の変更の中でシレッとやることになる。




名前付けを合わせる。
「リーダブルコード」などで「こういう書き方をすると読みやすい」という例がいくつも紹介されているが、そういう中でどの書き方を選ぶか？　というところに個性が出る。
例えば

n_items
itemsCound


設計を合わせる。モジュールの分割の粒度を揃える。
APIのデザインを合わせる。
引数の流儀を合わせる。



コミットログの書き方を揃える。
コミットメッセージに*有用な情報*を含めておかないといけない
 * 「ユーザーがグループに所属していない時にログインに失敗する問題を修正」
 * 「チケットの作成時に空のフィールドを許容しないように変更」
5W1Hのうちの「Why」
# いいかげんなコミットメッセージはログの有用性を損なう
 * 「バグ修正」
 * 「テスト」
 * 「腹減った」



## 悪いフィードバック：プロジェクトの背景を踏まえないハックの提案

筆者も、過去に強引な実装のパッチを代理で投稿してもらった事がありましたが、実装の筋が悪すぎたためか、それ以上話が進む事はありませんでした。

[61846 - Undockable My Sidebar - in a new window](https://bugzilla.mozilla.org/show_bug.cgi?id=61846)










## 何をしても駄目なときは

### フォークするしかない？　無闇にフォークしちゃ駄目？

問題を再定義して、プロジェクトのスコープに収まるようにして、筋の良い実装も用意して、それでも要望を受け入れてもらえない、ということはあります。最終的に要望を受け入れるかどうかは、そのプロジェクト内部の人が決定することです。外部から協力するだけの立場の人には、残念ですがその判断への介入はできません。

そういうときに、外部協力者の立場で取れる最後の手段が、プロジェクトのフォークです。設定されているライセンスの条件に従う限り、誰もが自由にそのOSSを改造し、再配布することができます。プルリクエストのために一時的にフォークするのではなく、改造の成果を元の開発プロジェクトに還元しないまま独立したプロジェクトとして継続する、という選択肢です。

リソースの無駄な分散を防ぐためにも、ユーザーの混乱を避けるためにも、*フォークは可能な限り避けるのが望ましい*です。どうしてもフォークする場合は、それ以後の開発やメンテナンスに要するすべてのリソースを自前でまかない、最後までそのソフトウェアの面倒を見続ける覚悟が必要です。

そのため、大きなOSSプロジェクトほど、フォークは珍しいです。近年で観測された大きなフォークといえば、WebKitからGoogleがフォークして始めたBlinkのように、フォーク主体に膨大なリソースがある場合か、OpenOffice.orgからのLibreOfficeya
ownCloudからのNextcloudのように、フォーク元の主要開発者達が何らかの理由で元プロジェクトから離反して、フォーク先にそのまま合流した場合くらいでしょう。

Firefox 28からフォークしたPale Moonや、Firefox 56からフォークしたWaterfoxのように、個人や少人数のグループが大規模なプロジェクトをフォークしたケースは、健全な状態を保ち続けられていないことが多い、という印象が筆者にはあります[^forked-gecko]。「フォークしたはいいものの、実際やってみたら意外と大変で、しばらくしたら更新が滞ってしまいました」というのは、ユーザーに過剰な期待を持たせた挙げ句に振り回してしまう、最悪の結末です。

[^forked-gecko]: これらのフォーク版は、フォーク以後のFirefoxで行われた性能向上や安全性向上のための抜本的な変更、最新のWeb技術への対応などが反映されておらず、最新のFirefoxと比べるとだいぶ見劣りする状態になっています。

### いざというときの選択肢として

しかし、そうは言っても「絶対にフォークしてはならない」というわけでもありません。

上述のとおり、プロジェクトの運営主体を完全に引き継いで責任を持って継続できそうなのであれば、あるいは、フォーク版を自分しか使わなくて不利益はすべて折り込み済みなのであれば、フォークは選択肢の一つとして考慮する価値があります。

実際に筆者にも、元プロジェクトには絶対に取り込んでもらえない独自の機能が、どうしても切実に業務上必要だという理由で、他の人の開発したOSSをフォークして以後、ニーズに応じて回収を続けながら10年近く維持し続けている[実例](https://github.com/clear-code/flex-confirm-mail/)があります。

「いざとなったらフォークして続けられる」という点は、OSSの強みです。もしフォークという手段が許されていなければ、やりたいビジネスを諦めたり、自分の使い方での致命的な不便を強いられたりしなくてはなりません。*覚悟と努力次第で困難を乗り越えられる余地が常に残されている*ということに筆者は安心感を覚え、逆に、プロプライエタリな製品には「これ、いつまで使い続けられるんだろう？」と不安を覚える、というのは、誇張ではなく実際の思いです。

「そんなタフな選択ができるのは、あなた（筆者）がスーパーエンジニアだからだ」と思われるでしょうか？　いいえ、そんなことはありません。筆者のOSS開発者としてのキャリア自体、他の人が開発を放棄して動かなくなってしまったソフトウェアを、再び動くように見よう見まねで修正したところから始まっています[^fork-of-non-free-software]。当時の筆者はオブジェクト指向もロクに分かっていないようなド素人でした。その元ソフトウェアはごく単純な物でしたが、それでも当時の筆者にとっては、全貌を理解しきれない、手に余る代物としか思えませんでした。

[^fork-of-non-free-software]: 実を言うと、このときフォークの元にしたソフトウェア（Mozilla Application Suiteのコンテキストメニュー拡張機能）にはオープンソースライセンスが設定されていませんでした。自分の記憶が正しければ、元の作者の方が「習作のような物なので権利は主張しない」という旨のことをおっしゃっていたため、パブリックドメイン扱いとして、こちらでオープンソースなライセンスを設定したという経緯だったように思います。

しかし、動かなくなっていた原因箇所をどうにか直して動く状態に戻せたことで、筆者はそれを足がかりとして学習を進められました。当時の筆者にとっては、入門書に書かれていた内容（基本中の基本）と自分のやりたかった事（高度なGUIを持つソフトウェア）との間のギャップが大きすぎて途方に暮れていましたが、「すでに動く状態のソフトウェア」のソースコードを読むことによって、「そうか、こういう機能を作りたいときはこういう書き方をするんだ」という実践的な知識を得ていけたのでした。

また、ソフトウェアの公開の仕方、継続的なメンテナンスの仕方、要望の受け答えの仕方など、コーディングそのものとは異なる周辺領域の様々な経験についても、そうして「自分のプロジェクト」を持つようになって以降、必要に迫られて身に着ける形で、非常に多くのものを得られました。

本書は「OSSへのフィードバックの仕方」を解説していますが、実際の所、*良いフィードバックとは「プロジェクトオーナーが受け取って嬉しいと思えるフィードバック」の一言に尽きます*。どうだったら嬉しいのかということは、プロジェクトオーナーの立場を経験してみるとよく分かる部分が多々あります。そういう機会になるという意味で、皆さんもフォークをきっかけに「自分のプロジェクト」を持ってみてはいかがでしょうか？
